/*
Evaluator Module - Abstract Syntax Tree Evaluation
====================================================

This module implements the evaluation phase of mathematical expression processing.
It traverses the Abstract Syntax Tree (AST) generated by the parser and computes
the final numeric result through recursive evaluation.

The evaluator handles:
- Arithmetic operations with appropriate error checking
- Mathematical functions with domain validation
- Type conversion and numeric representation limits
- IEEE 754 floating-point edge cases

Error conditions are rigorously checked to prevent:
- Division by zero
- Domain violations (sqrt of negatives, log of non-positives)
- Overflow conditions exceeding IEEE 754 limits
- Invalid mathematical operations
*/

package evaluator

import (
	"Axion/parser"
	"Axion/constants"
	"fmt"
	"math"
	"sort"
	"strconv"
)

var Vars = make(map[string]float64)

// factorial computes the factorial function with overflow protection
func factorial(n float64) (float64, error) {
	if n < 0 || n != math.Floor(n) {
		return 0, fmt.Errorf("factorial only defined for non-negative integers")
	}
	if n > 170 {
		return 0, fmt.Errorf("factorial too large: %g! exceeds maximum representable value (limit: 170!)", n)
	}
	result := 1.0
	for i := 2; i <= int(n); i++ {
		result *= float64(i)
	}
	return result, nil
}

// Eval recursively evaluates an AST node and returns its numeric value
func Eval(node *parser.Node) (float64, error) {
	if node == nil {
		return 0, fmt.Errorf("invalid node")
	}

	switch node.Type {
	case parser.NODE_NUMBER:
		val, err := strconv.ParseFloat(node.Value, 64)
		if err != nil {
			return 0, fmt.Errorf("invalid number %q", node.Value)
		}
		return val, nil

	case parser.NODE_ASSIGN:
		val, err := Eval(node.Right)
		if err != nil {
			return 0, err
		}
		Vars[node.Value] = val
		return val, nil

	case parser.NODE_IDENTIFIER:
		if v, ok := Vars[node.Value]; ok {
			return v, nil
		}
		if v, ok := constants.Get(node.Value); ok {
			return v, nil
		}
		return 0, fmt.Errorf("undefined variable or constant %s", node.Value)

	case parser.NODE_OPERATOR:
		if node.Value == "neg" { // unary negation
			left, err := Eval(node.Left)
			if err != nil {
				return 0, err
			}
			return -left, nil
		}

		left, err := Eval(node.Left)
		if err != nil {
			return 0, err
		}
		right, err := Eval(node.Right)
		if err != nil {
			return 0, err
		}

		switch node.Value {
		case "+":
			return left + right, nil
		case "-":
			return left - right, nil
		case "*":
			return left * right, nil
		case "/":
			if right == 0 {
				return 0, fmt.Errorf("division by zero")
			}
			return left / right, nil
		case "^":
			if right > 500 {
				return 0, fmt.Errorf("exponent too large: maximum allowed is 500")
			}
			return math.Pow(left, right), nil
		default:
			return 0, fmt.Errorf("unknown operator %q", node.Value)
		}

	case parser.NODE_FUNCTION:
		switch node.Value {

		// Single-argument functions
		case "sin", "cos", "tan", "asin", "acos", "atan", "sqrt", "exp", "abs", "ceil", "floor", "!":
			if len(node.Children) < 1 {
				return 0, fmt.Errorf("%s requires 1 argument", node.Value)
			}
			arg1, err := Eval(node.Children[0])
			if err != nil {
				return 0, err
			}
			switch node.Value {
			case "sin":
				return math.Sin(arg1 * math.Pi / 180), nil
			case "cos":
				return math.Cos(arg1 * math.Pi / 180), nil
			case "tan":
				if math.Mod(arg1, 180) == 90 {
					return 0, fmt.Errorf("tan(%gÂ°): undefined (asymptote)", arg1)
				}
				return math.Tan(arg1 * math.Pi / 180), nil
			case "asin":
				if arg1 < -1 || arg1 > 1 {
					return 0, fmt.Errorf("asin: domain error, input must be [-1,1]")
				}
				return math.Asin(arg1) * 180 / math.Pi, nil
			case "acos":
				if arg1 < -1 || arg1 > 1 {
					return 0, fmt.Errorf("acos: domain error, input must be [-1,1]")
				}
				return math.Acos(arg1) * 180 / math.Pi, nil
			case "atan":
				return math.Atan(arg1) * 180 / math.Pi, nil
			case "sqrt":
				if arg1 < 0 {
					return 0, fmt.Errorf("sqrt: negative number %g", arg1)
				}
				return math.Sqrt(arg1), nil
			case "exp":
				if arg1 > 709 {
					return 0, fmt.Errorf("exp overflow: %g", arg1)
				}
				return math.Exp(arg1), nil
			case "abs":
				return math.Abs(arg1), nil
			case "ceil":
				return math.Ceil(arg1), nil
			case "floor":
				return math.Floor(arg1), nil
			case "!":
				return factorial(arg1)
			}

		// Multi-argument functions
		case "mean":
			if len(node.Children) < 1 {
				return 0, fmt.Errorf("mean requires at least 1 argument")
			}
			sum := 0.0
			for _, child := range node.Children {
				val, err := Eval(child)
				if err != nil {
					return 0, err
				}
				sum += val
			}
			return sum / float64(len(node.Children)), nil

		case "median":
			if len(node.Children) < 1 {
				return 0, fmt.Errorf("median requires at least 1 argument")
			}
			vals := make([]float64, len(node.Children))
			for i, child := range node.Children {
				val, err := Eval(child)
				if err != nil {
					return 0, err
				}
				vals[i] = val
			}
			sort.Float64s(vals)
			n := len(vals)
			if n%2 == 1 {
				return vals[n/2], nil
			}
			return (vals[n/2-1] + vals[n/2]) / 2, nil

		case "mode":
			if len(node.Children) < 1 {
				return 0, fmt.Errorf("mode requires at least 1 argument")
			}
			freq := make(map[float64]int)
			maxCount := 0
			var mode float64
			for _, child := range node.Children {
				val, err := Eval(child)
				if err != nil {
					return 0, err
				}
				freq[val]++
				if freq[val] > maxCount {
					maxCount = freq[val]
					mode = val
				}
			}
			return mode, nil

		// Two-argument functions
		case "pow", "max", "min":
			if len(node.Children) < 2 {
				return 0, fmt.Errorf("%s requires 2 arguments", node.Value)
			}
			arg1, err := Eval(node.Children[0])
			if err != nil {
				return 0, err
			}
			arg2, err := Eval(node.Children[1])
			if err != nil {
				return 0, err
			}
			switch node.Value {
			case "pow":
				if arg1 == 0 && arg2 < 0 {
					return 0, fmt.Errorf("0 cannot be raised to negative power")
				}
				if arg1 < 0 && arg2 != math.Floor(arg2) {
					return 0, fmt.Errorf("negative base with non-integer exponent")
				}
				result := math.Pow(arg1, arg2)
				if math.IsInf(result, 0) {
					return 0, fmt.Errorf("pow(%g,%g) overflow", arg1, arg2)
				}
				return result, nil
			case "max":
				return math.Max(arg1, arg2), nil
			case "min":
				return math.Min(arg1, arg2), nil
			}

		default:
			return 0, fmt.Errorf("unknown function %q", node.Value)
		}

	default:
		return 0, fmt.Errorf("invalid node type")
	}
	return 0, fmt.Errorf("unreachable code")
}