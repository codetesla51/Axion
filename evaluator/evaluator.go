/*
Evaluator Module - Abstract Syntax Tree Evaluation
====================================================

This module implements the evaluation phase of mathematical expression processing.
It traverses the Abstract Syntax Tree (AST) generated by the parser and computes
the final numeric result through recursive evaluation.

The evaluator handles:
- Arithmetic operations with appropriate error checking
- Mathematical functions with domain validation
- Type conversion and numeric representation limits
- IEEE 754 floating-point edge cases

Error conditions are rigorously checked to prevent:
- Division by zero
- Domain violations (sqrt of negatives, log of non-positives)
- Overflow conditions exceeding IEEE 754 limits
- Invalid mathematical operations
*/

package evaluator

import (
	"Axion/parser"
	"fmt"
	"math"
	"strconv"
)

var Vars = make(map[string]float64)

// factorial computes the factorial function with overflow protection
// Returns error for negative inputs, non-integers, or values exceeding IEEE 754 limits
func factorial(n float64) (float64, error) {
	// Validate input domain: non-negative integers only
	if n < 0 || n != math.Floor(n) {
		return 0, fmt.Errorf("factorial only defined for non-negative integers")
	}

	// Prevent overflow: 170! is approximately 7.26e+306, 171! exceeds float64 maximum
	if n > 170 {
		return 0, fmt.Errorf("factorial too large: %g! exceeds maximum representable value (limit: 170!)", n)
	}

	// Compute factorial through iterative multiplication
	result := 1.0
	for i := 2; i <= int(n); i++ {
		result *= float64(i)
	}
	return result, nil
}

// Eval performs recursive evaluation of the Abstract Syntax Tree
// Returns the computed numeric result or an error for invalid operations
func Eval(node *parser.Node) (float64, error) {
	// Validate node existence
	if node == nil {
		return 0, fmt.Errorf("Invalid")
	}

	// Process node based on type classification
	switch node.Type {

	// Base case: numeric literals
	case parser.NODE_NUMBER:
		val, err := strconv.ParseFloat(node.Value, 64)
		if err != nil {
			return 0, fmt.Errorf("invalid number %q", node.Value)
		}
		return val, nil
	case parser.NODE_ASSIGN:
		val, err := Eval(node.Right)
		if err != nil {
			return 0, err
		}
		Vars[node.Value] = val
		return val, nil

	case parser.NODE_IDENTIFIER:
		if v, ok := Vars[node.Value]; ok {
			return v, nil
		}
		return 0, fmt.Errorf("undefined variable %s", node.Value)

	case parser.NODE_OPERATOR:
		// Handle unary negation operator
		if node.Value == "neg" {
			left, err := Eval(node.Left)
			if err != nil {
				return 0, err
			}
			return -left, nil
		}

		// Handle binary operators: evaluate both operands
		left, err := Eval(node.Left)
		if err != nil {
			return 0, err
		}
		right, err := Eval(node.Right)
		if err != nil {
			return 0, err
		}

		// Apply binary operation
		switch node.Value {
		case "+":
			return left + right, nil
		case "-":
			return left - right, nil
		case "*":
			return left * right, nil
		case "/":
			// Guard against division by zero
			if right == 0 {
				return 0, fmt.Errorf("division by zero")
			}
			return left / right, nil
		case "^":
			// Exponentiation using standard library
			if right > 500 {
				return 0, fmt.Errorf("exponent too large: maximum allowed is 500")
			}
			return math.Pow(left, right), nil
		default:
			return 0, fmt.Errorf("unknown operator %q", node.Value)
		}

	// Recursive case: function calls
	case parser.NODE_FUNCTION:
		// Validate minimum argument count
		if len(node.Children) < 1 {
			return 0, fmt.Errorf("function %q requires at least 1 argument", node.Value)
		}

		// Evaluate first function argument
		arg1, err := Eval(node.Children[0])
		if err != nil {
			return 0, err
		}

		// Dispatch function evaluation based on function name
		switch node.Value {

		// Trigonometric functions: input in degrees, internal computation in radians
		case "sin", "cos", "tan":
			radians := arg1 * math.Pi / 180
			switch node.Value {
			case "sin":
				return math.Sin(radians), nil
			case "cos":
				return math.Cos(radians), nil
			case "tan":
				// Check for tangent asymptotes at odd multiples of 90 degrees
				if math.Mod(arg1, 180) == 90 {
					return 0, fmt.Errorf("tan(%gÂ°): undefined (asymptote)", arg1)
				}
				return math.Tan(radians), nil
			}

		// Inverse trigonometric functions: output in degrees
		case "asin":
			// Domain restriction: [-1, 1]
			if arg1 < -1 || arg1 > 1 {
				return 0, fmt.Errorf("asin: domain error - input must be between -1 and 1, got %g", arg1)
			}
			return math.Asin(arg1) * 180 / math.Pi, nil

		case "acos":
			// Domain restriction: [-1, 1]
			if arg1 < -1 || arg1 > 1 {
				return 0, fmt.Errorf("acos: domain error - input must be between -1 and 1, got %g", arg1)
			}
			return math.Acos(arg1) * 180 / math.Pi, nil

		case "atan":
			// No domain restrictions for arctangent
			return math.Atan(arg1) * 180 / math.Pi, nil

		// Logarithmic functions
		case "ln":
			// Natural logarithm: domain restriction to positive reals
			if arg1 <= 0 {
				return 0, fmt.Errorf("log: domain error - logarithm undefined for non-positive numbers, got %g", arg1)
			}
			return math.Log(arg1), nil

		case "log":
			// Base-10 logarithm: domain restriction to positive reals
			if arg1 <= 0 {
				return 0, fmt.Errorf("log10: domain error - logarithm undefined for non-positive numbers, got %g", arg1)
			}
			return math.Log10(arg1), nil

		// Other single-argument functions
		case "sqrt":
			// Square root: domain restriction to non-negative reals
			if arg1 < 0 {
				return 0, fmt.Errorf("sqrt: domain error - cannot take square root of negative number, got %g", arg1)
			}
			return math.Sqrt(arg1), nil

		case "exp":
			// Exponential function: overflow protection
			if arg1 > 709 {
				return 0, fmt.Errorf("exp: overflow error - exp(%g) would exceed maximum representable value", arg1)
			}
			return math.Exp(arg1), nil

		// Utility functions without domain restrictions
		case "abs":
			return math.Abs(arg1), nil
		case "ceil":
			return math.Ceil(arg1), nil
		case "floor":
			return math.Floor(arg1), nil

		// Factorial function (postfix notation)
		case "!":
			val, err := factorial(arg1)
			if err != nil {
				return 0, err
			}
			return val, nil

		// Two-argument functions
		case "pow", "max", "min":
			// Validate argument count
			if len(node.Children) < 2 {
				return 0, fmt.Errorf("function %q requires 2 arguments", node.Value)
			}

			// Evaluate second argument
			arg2, err := Eval(node.Children[1])
			if err != nil {
				return 0, err
			}

			switch node.Value {
			case "pow":
				// Power function with domain validation
				if arg1 == 0 && arg2 < 0 {
					return 0, fmt.Errorf("pow: domain error - 0 raised to negative power is undefined")
				}
				if arg1 < 0 && arg2 != math.Floor(arg2) {
					return 0, fmt.Errorf("pow: domain error - negative base with non-integer exponent")
				}
				result := math.Pow(arg1, arg2)
				// Check for overflow to infinity
				if math.IsInf(result, 0) {
					return 0, fmt.Errorf("pow: overflow error - pow(%g, %g) exceeds representable range", arg1, arg2)
				}
				return result, nil
			case "max":
				return math.Max(arg1, arg2), nil
			case "min":
				return math.Min(arg1, arg2), nil
			}

		default:
			return 0, fmt.Errorf("unknown function %q", node.Value)
		}
	}

	// Fallback for unhandled node types
	return 0, fmt.Errorf("invalid node type")
}
