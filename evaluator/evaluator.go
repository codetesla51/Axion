/*
Evaluator Module - Expression Evaluation Engine
===============================================
Part of Axion CLI Calculator
Author: Uthman
Year: 2025

This module implements the final stage of expression processing, recursively
evaluating Abstract Syntax Trees (AST) generated by the parser to produce
numerical results. The evaluator handles complex mathematical operations,
function calls, variable management, and comprehensive error checking.

Core Functionality:
The evaluator performs depth-first traversal of AST nodes, dispatching
evaluation based on node type and handling mathematical operations with
proper error checking and domain validation.

Supported Operations:
- Basic Arithmetic: +, -, *, / with overflow and division-by-zero protection
- Exponentiation: ^ with overflow protection (max exponent: 500)
- Unary Operations: Negation with proper precedence handling
- Advanced Math: Factorial with domain validation (non-negative integers ≤ 170)

Mathematical Functions:
- Trigonometric: sin, cos, tan, asin, acos, atan (degree-based)
- Logarithmic: ln, log, log10, log2 with custom base support
- Exponential: exp with overflow protection
- Utility: abs, ceil, floor, round, trunc, sign
- Power Functions: pow, sqrt with domain validation
- Statistical: mean, median, mode, sum, product for multi-argument support
- Comparison: max, min for pairwise operations

Advanced Features:
- Variable Storage: Persistent variable assignment and retrieval
- Constant Integration: Mathematical constants (pi, e, etc.) from constants module
- Domain Validation: Prevents invalid operations (sqrt of negative, log of non-positive)
- Overflow Protection: Guards against numerical overflow in computations
- Type Safety: Ensures proper argument counts and types for all functions
- Error Context: Detailed error messages with operation context

Special Handling:
- Scientific Notation: Full support for exponential number formats
- Infinity Values: Proper handling of positive/negative infinity
- NaN Detection: Not-a-Number result identification and reporting
- Precision Control: Maintains numerical accuracy throughout calculations

Variable System:
- Dynamic Assignment: Runtime variable creation and modification
- Scope Management: Global variable storage across expressions
- Constant Access: Integration with predefined mathematical constants
- Name Resolution: Identifier lookup with proper error reporting

The evaluator ensures mathematical correctness while providing comprehensive
error handling and support for advanced mathematical operations.
*/
package evaluator

import (
	"Axion/constants"
	"Axion/parser"
	"fmt"
	"math"
	"sort"
	"strconv"
)

var Vars = make(map[string]float64)

// factorial computes the factorial function with overflow protection
func factorial(n float64) (float64, error) {
	if n < 0 || n != math.Floor(n) {
		return 0, fmt.Errorf("factorial only defined for non-negative integers")
	}
	if n > 170 {
		return 0, fmt.Errorf("factorial too large: %g! exceeds maximum representable value (limit: 170!)", n)
	}
	result := 1.0
	for i := 2; i <= int(n); i++ {
		result *= float64(i)
	}
	return result, nil
}

// Eval recursively evaluates an AST node and returns its numeric value
func Eval(node *parser.Node) (float64, error) {
	if node == nil {
		return 0, fmt.Errorf("invalid node")
	}

	switch node.Type {
	case parser.NODE_NUMBER:
		val, err := strconv.ParseFloat(node.Value, 64)
		if err != nil {
			return 0, fmt.Errorf("invalid number %q", node.Value)
		}
		return val, nil

	case parser.NODE_ASSIGN:
		val, err := Eval(node.Right)
		if err != nil {
			return 0, err
		}
		Vars[node.Value] = val
		return val, nil

	case parser.NODE_IDENTIFIER:
		if v, ok := Vars[node.Value]; ok {
			return v, nil
		}
		if v, ok := constants.Get(node.Value); ok {
			return v, nil
		}
		return 0, fmt.Errorf("undefined variable or constant %s", node.Value)

	case parser.NODE_OPERATOR:
		if node.Value == "neg" { // unary negation
			left, err := Eval(node.Left)
			if err != nil {
				return 0, err
			}
			return -left, nil
		}

		left, err := Eval(node.Left)
		if err != nil {
			return 0, err
		}
		right, err := Eval(node.Right)
		if err != nil {
			return 0, err
		}

		switch node.Value {
		case "+":
			return left + right, nil
		case "-":
			return left - right, nil
		case "*":
			return left * right, nil
		case "/":
			if right == 0 {
				return 0, fmt.Errorf("division by zero")
			}
			return left / right, nil
		case "^":
			if right > 500 {
				return 0, fmt.Errorf("exponent too large: maximum allowed is 500")
			}
			return math.Pow(left, right), nil
		default:
			return 0, fmt.Errorf("unknown operator %q", node.Value)
		}

	case parser.NODE_FUNCTION:
		switch node.Value {

		// EXISTING SINGLE-ARGUMENT FUNCTIONS
		case "sin", "cos", "tan", "asin", "acos", "atan", "sqrt", "exp", "abs", "ceil", "floor", "!":
			if len(node.Children) < 1 {
				return 0, fmt.Errorf("%s requires 1 argument", node.Value)
			}
			arg1, err := Eval(node.Children[0])
			if err != nil {
				return 0, err
			}
			switch node.Value {
			case "sin":
				return math.Sin(arg1 * math.Pi / 180), nil
			case "cos":
				return math.Cos(arg1 * math.Pi / 180), nil
			case "tan":
				if math.Mod(arg1, 180) == 90 {
					return 0, fmt.Errorf("tan(%g°): undefined (asymptote)", arg1)
				}
				return math.Tan(arg1 * math.Pi / 180), nil
			case "asin":
				if arg1 < -1 || arg1 > 1 {
					return 0, fmt.Errorf("asin: domain error, input must be [-1,1]")
				}
				return math.Asin(arg1) * 180 / math.Pi, nil
			case "acos":
				if arg1 < -1 || arg1 > 1 {
					return 0, fmt.Errorf("acos: domain error, input must be [-1,1]")
				}
				return math.Acos(arg1) * 180 / math.Pi, nil
			case "atan":
				return math.Atan(arg1) * 180 / math.Pi, nil
			case "sqrt":
				if arg1 < 0 {
					return 0, fmt.Errorf("sqrt: negative number %g", arg1)
				}
				return math.Sqrt(arg1), nil
			case "exp":
				if arg1 > 709 {
					return 0, fmt.Errorf("exp overflow: %g", arg1)
				}
				return math.Exp(arg1), nil
			case "abs":
				return math.Abs(arg1), nil
			case "ceil":
				return math.Ceil(arg1), nil
			case "floor":
				return math.Floor(arg1), nil
			case "!":
				return factorial(arg1)
			}

		
		case "ln", "log10", "round", "trunc", "sign", "deg2rad", "rad2deg":
			if len(node.Children) < 1 {
				return 0, fmt.Errorf("%s requires 1 argument", node.Value)
			}
			arg1, err := Eval(node.Children[0])
			if err != nil {
				return 0, err
			}
			switch node.Value {
			  	case "ln":
				if arg1 <= 0 {
					return 0, fmt.Errorf("log10: domain error, input must be positive")
				}
				return math.Log(arg1), nil
			
		
			case "round":
				return math.Round(arg1), nil
			case "trunc":
				return math.Trunc(arg1), nil
			case "sign":
				if arg1 > 0 {
					return 1, nil
				} else if arg1 < 0 {
					return -1, nil
				}
				return 0, nil
			case "deg2rad":
				return arg1 * math.Pi / 180, nil
			case "rad2deg":
				return arg1 * 180 / math.Pi, nil
			}

		case "log":
			if len(node.Children) < 1 {
				return 0, fmt.Errorf("log requires at least 1 argument")
			}
			if len(node.Children) == 1 {
				// log(x) = natural logarithm (same as ln)
				arg1, err := Eval(node.Children[0])
				if err != nil {
					return 0, err
				}
				if arg1 <= 0 {
					return 0, fmt.Errorf("log: domain error, input must be positive")
				}
				return math.Log10(arg1), nil
			} else if len(node.Children) == 2 {
				// log(x, base) = logarithm base 'base'
				arg1, err := Eval(node.Children[0])
				if err != nil {
					return 0, err
				}
				base, err := Eval(node.Children[1])
				if err != nil {
					return 0, err
				}
				if arg1 <= 0 {
					return 0, fmt.Errorf("log: domain error, value must be positive")
				}
				if base <= 0 || base == 1 {
					return 0, fmt.Errorf("log: base must be positive and not equal to 1")
				}
				return math.Log(arg1) / math.Log(base), nil
			} else {
				return 0, fmt.Errorf("log accepts 1 or 2 arguments, got %d", len(node.Children))
			}

		// NEW SINGLE-ARGUMENT FUNCTIONS (CONTINUED)
		case "log2":
			if len(node.Children) < 1 {
				return 0, fmt.Errorf("log2 requires 1 argument")
			}
			arg1, err := Eval(node.Children[0])
			if err != nil {
				return 0, err
			}
			if arg1 <= 0 {
				return 0, fmt.Errorf("log2: domain error, input must be positive")
			}
			return math.Log2(arg1), nil

		case "mean":
			if len(node.Children) < 1 {
				return 0, fmt.Errorf("mean requires at least 1 argument")
			}
			sum := 0.0
			for _, child := range node.Children {
				val, err := Eval(child)
				if err != nil {
					return 0, err
				}
				sum += val
			}
			return sum / float64(len(node.Children)), nil

		case "median":
			if len(node.Children) < 1 {
				return 0, fmt.Errorf("median requires at least 1 argument")
			}
			vals := make([]float64, len(node.Children))
			for i, child := range node.Children {
				val, err := Eval(child)
				if err != nil {
					return 0, err
				}
				vals[i] = val
			}
			sort.Float64s(vals)
			n := len(vals)
			if n%2 == 1 {
				return vals[n/2], nil
			}
			return (vals[n/2-1] + vals[n/2]) / 2, nil

		case "mode":
			if len(node.Children) < 1 {
				return 0, fmt.Errorf("mode requires at least 1 argument")
			}
			freq := make(map[float64]int)
			maxCount := 0
			var mode float64
			for _, child := range node.Children {
				val, err := Eval(child)
				if err != nil {
					return 0, err
				}
				freq[val]++
				if freq[val] > maxCount {
					maxCount = freq[val]
					mode = val
				}
			}
			return mode, nil

		// TWO-ARGUMENT FUNCTIONS
		case "pow", "max", "min", "atan2", "mod":
			if len(node.Children) < 2 {
				return 0, fmt.Errorf("%s requires 2 arguments", node.Value)
			}
			arg1, err := Eval(node.Children[0])
			if err != nil {
				return 0, err
			}
			arg2, err := Eval(node.Children[1])
			if err != nil {
				return 0, err
			}
			switch node.Value {
			case "pow":
				if arg1 == 0 && arg2 < 0 {
					return 0, fmt.Errorf("0 cannot be raised to negative power")
				}
				if arg1 < 0 && arg2 != math.Floor(arg2) {
					return 0, fmt.Errorf("negative base with non-integer exponent")
				}
				result := math.Pow(arg1, arg2)
				if math.IsInf(result, 0) {
					return 0, fmt.Errorf("pow(%g,%g) overflow", arg1, arg2)
				}
				return result, nil
			case "max":
				return math.Max(arg1, arg2), nil
			case "min":
				return math.Min(arg1, arg2), nil
			case "atan2":
				return math.Atan2(arg1, arg2) * 180 / math.Pi, nil
			case "mod":
				if arg2 == 0 {
					return 0, fmt.Errorf("mod: division by zero")
				}
				return math.Mod(arg1, arg2), nil
			}

		case "sum", "product":
			if len(node.Children) < 1 {
				return 0, fmt.Errorf("%s requires at least 1 argument", node.Value)
			}
			if node.Value == "sum" {
				sum := 0.0
				for _, child := range node.Children {
					val, err := Eval(child)
					if err != nil {
						return 0, err
					}
					sum += val
				}
				return sum, nil
			} else { // product
				product := 1.0
				for _, child := range node.Children {
					val, err := Eval(child)
					if err != nil {
						return 0, err
					}
					product *= val
				}
				return product, nil
			}

		default:
			return 0, fmt.Errorf("unknown function %q", node.Value)
		}

	default:
		return 0, fmt.Errorf("invalid node type")
	}
	return 0, fmt.Errorf("invalid node type")
}
